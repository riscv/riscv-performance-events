.RVV group events
[width="100%",cols="30%,70%",options="header",]
|===
|Name |Description
|INST.RVV.SPEC |Number of RVV instructions executed
|INST.RVV.INT.SPEC |Number of integer RVV instructions executed
|INST.RVV.FP.SPEC |Number of floating point RVV instructions executed
|RVV.ELEMENT.UNMASKED.INT8.SPEC |Number of 8-bit integer element operation executed. For example, if we have SEW=8, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.UNMASKED.INT8 counter by 16. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV.ELEMENT.UNMASKED.INT8 will be incremented by 8. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.INT8.SPEC |Number of 8-bit integer element operation executed. For example, if we have SEW=8, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.INT8 counter by 16. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.INT8 will still be incremented by 16. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.UNMASKED.INT16.SPEC |Number of 16-bit integer element operation executed. For example, if we have SEW=16, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.UNMASKED.INT16 counter by 8. Masked-out elements should not increment the counter - so in the previous example half of the lanes are masked the RVV.ELEMENT.UNMASKED.INT16 counter will be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.INT16.SPEC |Number of 16-bit integer element operation executed. For example, if we have SEW=16, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.INT16 counter by 8. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.INT16 counter will still be incremented by 8. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.UNMASKED.INT32.SPEC |Number of 32-bit integer element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.UNMASKED.INT16 counter by 4. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV.ELEMENT.UNMASKED.INT32 counter will be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.INT32.SPEC |Number of 32-bit integer element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.INT16 counter by 4. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.INT32 counter will still be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.UNMASKED.INT64.SPEC |Number of 64-bit integer element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.UNMASKED.INT64 counter by 2. Masked-out elements should not increment the counter - so in the previous example half of the lanes are masked the RVV.ELEMENT.UNMASKED.INT64 counter will be incremented by 1. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.INT64.SPEC |Number of 64-bit integer element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV.ELEMENT.INT64 counter by 2. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.INT64 counter will still be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.UNMASKED.FP_SINGLE.SPEC |Number of single-precision floating point element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV.ELEMENT.UNMASKED.FP_SINGLE counter by 4. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV.ELEMENT.UNMASKED.FP_SINGLE counter will be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.FP_SINGLE.SPEC |Number of single-precision floating point element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV.ELEMENT.FP_SINGLE counter by 4. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.FP_SINGLE counter will still be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.UNMASKED.FP_DOUBLE.SPEC |Number of double-precision floating point element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV.ELEMENT.UNMASKED.FP_DOUBLE counter by 2. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV.ELEMENT.UNMASKED.FP_DOUBLE counter will be incremented by 1. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|RVV.ELEMENT.FP_DOUBLE.SPEC |Number of double-precision floating point element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV.ELEMENT.FP_DOUBLE counter by 2. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV.ELEMENT.FP_DOUBLE counter will still be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition.
|===

